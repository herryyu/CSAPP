%
%                                                      __----~~~~~~~~~~~------___
%                                     .  .   ~~//====......          __--~ ~~
%                     -.            \_|//     |||\\  ~~~~~~::::... /~
%                  ___-==_       _-~o~  \/    |||  \\            _/~~-
%          __---~~~.==~||\=_    -_--~/_-~|-   |\\   \\        _/~
%      _-~~     .=~    |  \\-_    '-~7  /-   /  ||    \      /
%    .~       .~       |   \\ -_    /  /-   /   ||      \   /
%   /  ____  /         |     \\ ~-_/  /|- _/   .||       \ /
%   |~~    ~~|--~~~~--_ \     ~==-/   | \~--===~~        .\
%            '         ~-|      /|    |-~\~~       __--~~
%                        |-~~-_/ |    |   ~\_   _-~            /\
%                             /  \     \__   \/~                \__
%                         _--~ _/ | .-~~____--~-/                  ~~==.
%                        ((->/~   '.|||' -_|    ~~-/ ,              . _||
%                                   -_     ~\      ~~---l__i__i__i--~~_/
%                                   _-~-__   ~)  \--______________--~~
%                                 //.-~~~-~_--~- |-------~~~~~~~~
%                                        //.-~~~--\
%                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%  INRAINBOWS
%  2022-01-31 19:18:05

\chapter{计算机系统漫游}\label{CHP1}

\begin{minted}{C}
    #include <stdio.h>
    
    int main()
    {
        printf("hello, world\n");
        return 0;
    }
\end{minted}

\smallskip
本章，通过跟踪该hello程序的生命周期进行学习。

\mksec{信息就是位+上下文}
大部分计算机使用ASCII标准表示字符，即用单字节整数值表示各个字符。\mkref{FIGURE1-1}{图 1-1} 为\texttt{hello.c} 的ASCII表示。

\smallskip
\begin{figure}[htbp]
    \centering
    \includegraphics[scale=0.3]{1-1}
    \caption{hello.c 的ASCII文本表示}\label{FIGURE1-1}
\end{figure}

\begin{itemize}
    \item hello程序的生命周期由其源程序（文件）开始，即\texttt{hello.c} 。
    \item 源程序是由0和1组成的位\textit{bit}序列。
    \item 8个bit一组，称为字节\textit{byte}。
    \item 各字节表示程序中的某些文本字符。
    \item 每个文本行由一个不可见的'\texttt{\textbackslash n}'结尾。
    \item 像\texttt{hello.c} 这样仅含ASCII字符的称为\texttt{文本文件}，其它的都叫\texttt{二进制文件}。
    \item \texttt{hello.c} 的启示：系统中的所有信息---磁盘文件、内存程序、内存存放的用户数据以及网络传输数据，均是由比特序列表示的。
    \item 区分不同数据对象的方法：分辨读取这些数据对象时的上下文。比如，在不同上下文中，一个相同的字节序列可能表示一个整数、浮点数、字符串或机器指令。
\end{itemize}

\smallskip
我们需要了解数字的机器表示，因为它们与实际整数和实数不同，是对真值的有限逼近。\mkref{CHP2}{第二章}有详细描述。

\mksec{程序被其它程序翻译成不同的格式}
为使\texttt{hello.c} 在系统上运行，每条C语句必须被其它程序转为一系列低级\texttt{机器语言}指令。这些指令被打包为\texttt{可执行目标程序}格式，并以
二进制文件形式存放于磁盘。目标程序也称\texttt{可执行目标文件}。

\medskip
在Unix上，源文件到目标文件的转换由\texttt{编译器套件}完成：\texttt{linux>} \textittt{gcc -o hello hello.c}

\medskip
GCC读取源程序\texttt{hello.c} ，并将其编译为可执行目标文件 \texttt{hello} 。此编译过程分四个阶段：

\medskip
\begin{enumerate}
    \item 预处理阶段：预处理器\textit{cpp}将\texttt{hello.c} 中以\#开头的命令进行展开（ \texttt{\#define}、\texttt{\#include} ），并得到
          新文件\texttt{hello.i} 。
    \item 编译阶段：编译器\textit{cc1}将\texttt{hello.i}的C语句编译为汇编语句，变为\texttt{hello.s} 。如下所示：
          \begin{minted}[linenos]{asm}
    main:
        subq      $8, %rsp
        movl      $.LC0, %edi
        call      puts
        movl      $0, %eax
        addq      $8, %rsp
        ret
          \end{minted}
    \item 汇编阶段：汇编器\textit{as}将\texttt{hello.s} 编译为机器指令，并打包为\texttt{可重定位目标程序}\texttt{hello.o} 。此时
          \texttt{hello.o} 为二进制文件。
    \item 链接阶段：注意\texttt{hello} 调用了\texttt{printf} 函数。该函数被置于C标准库预编译好的\texttt{printf.o}中，它须以某种方式被合并到
          \texttt{hello.o} 中。链接器\textit{ld}负责完成该操作，并得到\texttt{hello}可执行文件。
\end{enumerate}
    
\mksec{了解编译系统如何工作是大有益处的}
有一些重要原因促使程序员了解编译系统是如何工作的：

\medskip
\begin{itemize}
    \item 优化程序性能。
    \item 理解链接时出现的错误。
    \item 避免安全漏洞。
\end{itemize}

\mksec{处理器读并解释存储在内存中的指令}
现在\texttt{hello.c} 已被编译为\texttt{hello} 可执行文件。要在Unix上运行之，可运行以下shell指令：
\smallskip
\begin{minted}{shell}
    linux> ./hello
    hello, world
    linux>
\end{minted}

\smallskip
shell是一个命令行解释器，它输出一个提示符，等待一个命令行输入，并执行该命令。若命令行的第一个单词非内置shell指令，则shell假设其为一个可执行文件的名字，
shell加载并运行之。

\mksubsec{系统的硬件组成}
\mkref{FIGURE1-2}{图 1-2} 展示了Intel系统产品族的模型。

\smallskip
\begin{figure}[htbp]
    \centering
    \includegraphics[scale=0.33]{1-2}
    \caption{一个典型系统的硬件组成}\label{FIGURE1-2}
    \footnotesize{CPU: 中央处理单元； ALU：算数逻辑单元; PC：程序计数器； USB：通用串行总线}
\end{figure}

\smallskip
\begin{enumerate}
    \item 总线------贯穿整个系统的一组电子管道。其携带信息字节在各部件间传递。总线传送的是定长字节块，即\texttt{字}(word)。字包含的字节数（字长）与
          目标系统相关。大多数机器字长为4bytes/32bits或8bytes/64bits。
    \item I/O设备------在图例中包含四个I/O设备：作为输入的鼠标键盘、作为输出的显示器、磁盘驱动器。各I/O设备均由一个\texttt{控制器}或
          \texttt{适配器}与I/O总线相连。控制器与适配器的区别为封装方式。控制器是I/O设备自身或主板上的芯片组；适配器为一块插在主板上的卡。无论如何，他
          俩的功能相同。\\
          \mkref{CHP6}{第六章}详解了磁盘I/O工作原理；\mkref{CHP10}{第十章}讨论了Unix I/O接口的使用。
    \item 主存------一种临时存储设备，其存放处理器需要的程序与数据。主存在物理上由若干\texttt{动态随机存取存储器(DRAM)}芯片组成；在逻辑上是一个线性
          的字节数组，每个字节存放一个地址，地址从零开始。\mkref{CHP6}{第六章}将具体介绍存储器技术。
    \item 处理器------\texttt{中央处理单元}(CPU)。负责解释执行主存中的指令。CPU核心为一个大小为一个word的寄存器，即\texttt{程序计数器}(PC)。PC
          在任何时候均指向主存中的某条机器指令地址。CPU从通电到断电，遵循\texttt{指令集架构}决定的操作模型来进行一系列操作。这些操作围绕主存、
          \texttt{寄存器文件}(register file)与ALU进行。寄存器文件由一些名字不同的单字长寄存器组成；ALU计算新的数据与地址。下面是一个简单例子：
          \begin{itemize}
              \item 加载：从主存负值一个byte或一个word到寄存器，以覆盖寄存器原本内容。
              \item 存储：从寄存器负值一个byte或一个word到主存某处，以覆盖该处原本内容。
              \item 操作：将两个寄存器的内容负值到ALU，ALU对这两个word做算术运算，将结果存入某寄存器中，并覆盖该寄存器原本内容。
              \item 跳转：从指令本身抽取一个word，将其复制到PC中，以覆盖PC原值。
          \end{itemize}
          实际上CPU使用了复杂机制来加速程序执行。因此将CPU的指令集架构与CPU\texttt{微体系结构}区分开来。指令集架构描述每条机器指令的效果；微体系结构
          描述CPU实际上的实现方式。\mkref{CHP3}{第三章}讨论了指令集架构，\mkref{CHP3}{第四章}则着重介绍微体系结构。\mkref{CHP5}{第五章}展示了
          一个现代CPU的工作模型。
\end{enumerate}

\mksubsec{运行hello程序}   
当在键盘上输入"\texttt{./hello} "后，shell将字符逐一读入寄存器，再放进内存，如\mkref{FIGURE1-3}{图 1-3}。

\smallskip
\begin{figure}[htbp]
    \centering
    \includegraphics[scale=0.3]{1-3}
    \caption{从键盘上读取hello命令}\label{FIGURE1-3}
\end{figure}

\smallskip
敲击回车后，shell执行一系列指令加载\texttt{hello} ，将\texttt{hello} 目标文件中的代码与数据复制到主存。

\medskip
\texttt{直接存储器存取}(DMA，\mkref{CHP6}{第六章}介绍)技术可使数据不通过CPU而直达主存，如\mkref{FIGURE1-4}{图 1-4}。

\smallskip
\begin{figure}[htbp]
    \centering
    \includegraphics[scale=0.3]{1-4}
    \caption{从磁盘加载可执行文件到主存}\label{FIGURE1-4}
\end{figure}

\smallskip
\texttt{hello} 被加载完成后，CPU开始执行\texttt{hello} 中\texttt{main} 函数中的机器指令。指令将串
"\texttt{hello, world{\textbackslash}n}"中的字节从主存复制到寄存器文件，接着从寄存器文件复制到显示设备并显示，如\mkref{FIGURE1-5}{图 1-5}。

\smallskip
\begin{figure}[htbp]
    \centering
    \includegraphics[scale=0.3]{1-5}
    \caption{将输出字符串从存储器写到显示器}\label{FIGURE1-5}
\end{figure}

\mksec{高速缓存至关重要}
根据机械原理，较大存储设备比较小的运行得慢，而快速设备造价远高于低俗设备。典型的便是寄存器文件和主存，CPU从寄存器中读数据比主存要快100倍。针对这种差异，
可采用\texttt{高速缓存存储器}(cache memory，简称cache、高速缓存)作为CPU需要信息的临时存放点。\mkref{FIGURE1-6}{图 1-6}是一个典型系统中的高速
缓存。
\begin{itemize}
    \item CPU上的L1 cache速度与寄存器文件差不多。
    \item L2 cache由一条特殊总线与CPU连接，其速度比L1慢5倍，但仍比主存快5~10倍。
    \item L1与L2是用\texttt{静态随机访问存储器}(SRAM)实现的，现代CPU有L3 cache。
    \item cache的\texttt{局部性原理}：cache中会尽可能存放程序经常在主存中访问的数据与代码，使得大部分主存操作可在cache中完成。
\end{itemize}

\smallskip
\begin{figure}[htbp]
    \centering
    \includegraphics[scale=0.3]{1-6}
    \caption{高速缓存存储器}\label{FIGURE1-6}
\end{figure}

\mksec{存储设备形成层次结构}
\begin{itemize}
    \item 每个计算机系统中的存储设备都被组织成了一个\texttt{存储器层次结构}，如\mkref{FIGURE1-7}{图 1-7}。
    \item 从上至下/速度越慢/容量越大/逐字节造价约便宜。
    \item 该层次结构思想为上一层存储器作为第一层存储器的高速缓存。
\end{itemize}

\smallskip
\begin{figure}[htbp]
    \centering
    \includegraphics[scale=0.3]{1-7}
    \caption{一个存储器层次结构的示例}\label{FIGURE1-7}
\end{figure}

\mksec{操作系统管理硬件}
\texttt{操作系统}(OS)是程序与硬件之间的媒介，如\mkref{FIGURE1-8}{图 1-8}。OS两个基本功能：(1)防止程序滥用硬件；(2)为程序提供不同硬件的统一抽象。
OS通过几个抽象概念来实现这两功能（进程、虚拟内存、文件），如\mkref{FIGURE1-9}{图 1-9}。

\begin{figure}[htbp]
    \centering
    \begin{minipage}[t]{0.48\textwidth}
        \centering
        \includegraphics[width=6cm]{1-8}
        \caption{计算机系统的分层视图}\label{FIGURE1-8}
    \end{minipage}
    \begin{minipage}[t]{0.48\textwidth}
        \centering
        \includegraphics[width=6cm]{1-9}
        \caption{操作系统提供的抽象表示}\label{FIGURE1-9}
    \end{minipage}
\end{figure}

\mksubsec{进程}
\texttt{进程}是OS对运行时程序的抽象。一个OS上可同时运行多个进程，各进程像是独占地在使用硬件。\texttt{并发运行}指一个进程与另一个进程的指令交错执行。
在现代单/多核CPU系统中，单CPU看起来像并发地执行多个进程，这是通过处理器的进程切换实现的。OS这种交错执行机制称为\texttt{上下文切换}。

\medskip
\begin{itemize}
    \item OS保持跟踪进程运行状态信息。这种状态便是\texttt{上下文}(context)
    \item 上下文包含PC、寄存器文件、主存等内容。
    \item 单CPU系统仅能执行一个进程的代码，OS可以通过\texttt{上下文切换}在进程之间转移控制权。
    \item \texttt{上下文切换}保存当前进程的上下文，恢复新进程的context，然后将控制权转到新进程。如\mkref{FIGURE1-10}{图 1-10}
\end{itemize}

\smallskip
\begin{figure}[htbp]
    \centering
    \includegraphics[scale=0.4]{1-10}
    \caption{进程的上下文切换}\label{FIGURE1-10}
\end{figure}

在之前例子中有两个并发进程：shell与\texttt{hello} 。首先是shell在运行，敲入命令后，shell调用系统Api执行请求，此时控制权交由OS。OS保存shell的
context并创建新\texttt{hello} 进程及其context，接着将控制权交由\texttt{hello} 进程。它终止后，OS恢复shell的context，并将控制权传回它。

\medskip
如\mkref{FIGURE1-10}{图 1-10}，进程间切换由操作系统\texttt{内核}(kernel)管理。kernel是常驻主存的部分OS代码。程序需调用OS功能时，执行一条
\texttt{系统调用}(system call)指令将控制权传给kernel；kernel执行请求操作并返回程序。

\medskip
\textbf{kernel非独立进程，其为OS管理全部进程所用代码与数据结构的集合}。

\mksubsec{线程}
现代OS中单进程可由多个叫做\texttt{线程}的执行单元组成，各线程运行在进程的context中，共享相同代码与全局数据。线程间数据共享比进程间容易，因为线程一般
比进程高效。

\mksubsec{虚拟内存}
虚拟内存是一个抽象概念。

\mksec{重要主题}
\mksubsec{Amdahl定律}
思想：对系统某部分进行加速的操作对系统整体性能的影响取决于该部分的\textbf{重要性}与\textbf{加速程度}。

\medskip
\begin{itemize}
    \item 系统执行某程序所需时间为$T_{old}$.
    \item 系统某部分所需执行时间与$T_{old}$比例为$\alpha$.
    \item 该部分性能提升比例为$k$.
    \item 可得出，该部分初始执行时间为${\alpha}T_{old}$，加速后时间为$({\alpha}T_{old})/k$.
    \item 则系统新总执行时间为：$T_{new}=(1-\alpha)T_{old}+({\alpha}T_{old})/k=T_{old}[(1-\alpha)+\alpha/k]$
\end{itemize}
即可得出加速比：
\begin{equation}
    \begin{aligned}
        S &= T_{old}/T_{new}\label{eq1.1} \\
          &= \frac{1}{(1-\alpha)+\alpha/k}
    \end{aligned}
\end{equation}

\bigskip
\bluetxt{练习题 1.1}{\quad}运送土豆，全程2500km。因为限速，你的平均速度为100km/h，全程耗时25h。
\begin{enumerate}
    \item[A.] 若行程中总长1500km的蒙大拿州速度可以达到150km/h，则整体行程加速比为多少？\\
    \bluetxt{解1}：$t_{part} = 1500km/150km/h=10h$，则$T_{new}=(2500km-1500km)/100km/h+10h=20h$。\\
    所以$S=T_{old}/T_{new}=25h/20h=1.25$。\\
    \bluetxt{解2}：易知$\alpha=1500km/2500km=0.6$、$k=150/100=1.5$ \\
    则根据Amdahl公式 \eqref{eq1.1} ，$S=1/[(1-0.6)+0.6/1.5]=1.25$。
    \item[B.] 若想让整体加速比为1.67X，则必须以多块的速度通过蒙大拿州？\\
    \bluetxt{解1}：$S=T_{old}/T_{new}=25h/T_{new}=1.67 \Rightarrow T_{new}=2500/167$。而$T_{new}=10h+1500km/V$ \\
    由题意，$10h+1500km/V \leq 2500/167 \Rightarrow V \geq 301.8km/h$ \\
    对$V$取整，则速度至少为302km/h。\\
    \bluetxt{解2}：根据Amdahl公式 \eqref{eq1.1} ，$S=1/[(1-0.6)+0.6/k]=1.67$ \\
    解得$k\approx 3.02$，则$V=3.02 \times 100km/h = 302km/h$。
\end{enumerate}

\bluetxt{练习题 1.2}{\quad}下版本软件性能改进2X，该任务分配给你。你已确认仅80\%的系统能被改进。则该部分需改进多少才可达到整体性能目标？\\
\bluetxt{解}：由题意，$2=1/[(1-0.8)+0.8/k]$，解得$k=2.67$

\bigskip
Amdahl定律一个特殊情况是$k \rightarrow \infty$的情况，此时对应子部分加速到几乎不花时间，则有：
\begin{equation}
    S_{\infty} = \frac{1}{(1-\alpha)}
\end{equation}

从这个式子看出，即使局部被无限加速，整体的提升仍是有限的。